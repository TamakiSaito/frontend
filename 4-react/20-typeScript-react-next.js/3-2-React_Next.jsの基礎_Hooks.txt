-- React Hooks 
  : React 16.8で導入された機能で、クラスコンポーネントを使用せずに
    関数コンポーネント内で状態管理やライフサイクル管理ができる仕組み

  1. useState : 状態(state)を管理
      const = [状態, 更新関数] = useState(初期値)
        ・useState(引数1) → '引数1: 初期値'
        ・戻り値は配列 : 配列の1番目に、現在の状態を表す変数, 2番目に更新関数
          更新関数を呼び出すと状態が変化し、フックがあるコンポーネントは再描画される

  1. useReducer : useStateの代わりに複雑な状態管理を行うために使用します
                  actionが複数がある場合、dispatchでstateを区分する為

      reducer(現在の状態, action) {
        return '次の状態'
      }
      const [現在の状態, dispatch] = useReducer(reducer, reducerに渡される初期状態)
      ・dispatch関数にactionを渡す事で状態を更新できる

      ・actionには通常、type（何をするのか）とpayload（必要な追加データ）が含まれる
        dispatch({ type: 'addTodo', payload: { text: '新しいタスク' } });
      
      - useReducer使用例
      ・状態管理が複数のアクションや条件分岐を含むとき
      ・ひとつの状態に対して複数の状態変更ロジックが必要なとき
      ・状態と更新ロジックを分離してコードを整理したいとき

      
  1. useMemo / useCallback : パフォーマンス最適化のために計算結果や関数をメモ化する
                            ・useCallback: 関数の再生成を防ぎ、主に子コンポーネントの再レンダリングを抑制するために使う
                            ・useMemo: 計算結果をメモ化し、再レンダリング時の余分な計算を避けるために使う
  
     
    -- useMemo : 計算コストの高い処理の結果をメモ化するためのHook
                 再レンダリング時に不要な計算を避けることで、パフォーマンスを向上させる

                  戻り値：値
                  const memoizedValue = useMemo(
                    () => {
                      return 計算結果;
                    },
                    [依存する値]
                  );

                  - useMemo使用例
                    ・計算コストが高い処理の結果をメモ化したいとき
                      計算に時間がかかる処理があり、依存値が変わらない限り同じ結果を使いたい場合
    
    -- useCallback : 関数の再生成を防ぐためのHook
                     Reactはコンポーネントが再レンダリングされる度に、関数が新しく生成されます。これを抑えるのがuseCallbackの目的

                      戻り値：関数
                      const memoizedCallback = useCallback(
                        () => {
                          // 実行する処理
                        },
                        [依存する値]
                      );

                      - useCallback使用例
                        ・関数をpropsで渡す場合など、再生成を避けたいとき
                          子コンポーネントに関数を渡すとき
                          子コンポーネントに関数をpropsとして渡す場合、親が再レンダリングされると関数も再生成される
                          このとき、子コンポーネントが不要に再レンダリングされるのを防ぐためにuseCallbackを使う

  1. useEffect / useLayoutEffect : コンポーネントの'副作用'処理を行う際に使用(実行タイミングが違う)

                    -- useEffect : ・DOMが更新された後に'非同期'で実行されるHook
                                   ・副作用処理（データの取得、イベントリスナーの設定など）を記述するために使う
                                    (DOMのレイアウトやスタイルの計算、スクロール位置の設定など、描画前に行う必要がある処理に適してる)
                                    ※レンダリングの後にuseEffectの中身が実行される
                                    
                                    useEffect(() => {
                                      // 副作用処理
                                      return () => {
                                        // クリーンアップ処理（オプション）
                                      };
                                      // 第2引数でuseEffectの中身を実行するタイミングを指定できる
                                      // 第2引数が空の配列:リロード1回のみ・変数を入れる:変数の値が変わった時に実行する
                                    }, [依存する値]); 
  
                    -- useLayoutEffect : ・DOMが更新される直前に'同期的'に実行されるHook
                                         ・副作用処理がDOMの更新に影響を与える場合に使う

                                         useLayoutEffect(() => {
                                          // 副作用処理
                                          return () => {
                                            // クリーンアップ処理（オプション）
                                          };
                                        }, [依存する値]);

  1. useContext : コンテキストを利用して、複数のコンポーネント間でデータ（状態や関数など）を共有するために使用
                  
                  -- Contextを作成する
                  const MyContext = React.createContext(defaultValue);
                  -- useContextで利用する
                  const value = useContext(MyContext);

                  ・useContextは、Reactコンテキストを簡単に使えるようにするHook
                  ・コンテキストの値を直接取得できる
                  ・クラスコンポーネントでのContext.Consumerを使う代わりに、シンプルに記述可能

                  - useContext使うべき場面
                    1. グローバルなデータの共有
                      ・ユーザー情報（名前、認証トークンなど）
                      ・テーマ（ライトモード/ダークモード）
                      ・ローカル設定（言語、地域など）
                      ・propsの受け渡しが煩雑なとき

                    2. コンポーネント階層が深い場合に有効

  1. useRef : DOMへの参照や状態の永続的な値を保持する
              ・DOM要素へのアクセス
                特定のHTML要素に直接アクセスし、操作を行う
              ・'再レンダリングされない'値の保存
                変数のように使って値を保存できるが、値が変更されても再レンダリングが発生しない
                
                const ref = useRef(initialValue);
                


-- Reactコンポーネントの種類
  1. ステートを持つコンポーネント
     内部で状態（state）を管理し、動的な変化を扱うコンポーネント
     例: ボタンのカウンター、入力フォーム、APIデータを使うリスト

  1. ステートを持たないコンポーネント
     状態を持たず、表示だけを担当するシンプルなコンポーネント
     例: ラベルやタイトル、親からデータを受け取って表示するだけのパーツ

-- dispatch : actionを発行する関数
              ReactのuseReducerフックやReduxで使われ、「どのような状態変更を行うか」をアプリに伝える役割

              1. dispatchがすること
                ・actionを指定してreducer関数に送る（「これをやって!」と指示を出す）
                ・actionに基づいてreducer関数が新しい状態（state）を計算する

              2. dispatchの仕組み
                ・dispatchは単なる関数で、actionというオブジェクトを引数として受け取ります。
                ・actionはtypeというキーを必ず含む。他に必要なデータはpayloadとして渡す。
              
              3. 役割の流れ
                ①ユーザー操作が発生（ボタンを押すなど）
                ②dispatchを呼び出す（「この操作をしてほしい」と伝える）
                ③アクションがreducerに送られる
                ④reducerが状態を更新（アクションの内容に基づいて）

-- Contextの基本概念 : ・Contextは、親コンポーネントから子コンポーネントにプロパティを渡す仕組みを簡略化するための仕組み
                      ・普通は「propsでデータを渡す」方法を使いますが、コンポーネント階層が深いと面倒になることがあります。これを「プロップスドリリング/props drilling」という
                      ・Contextを使うと、「必要なコンポーネントだけがデータを取得」できるようになる